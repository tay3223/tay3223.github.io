(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{443:function(s,e,t){"use strict";t.r(e);var _=t(24),v=Object(_.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"深入理解resource-qos"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入理解resource-qos"}},[s._v("#")]),s._v(" 深入理解Resource QoS")]),s._v(" "),t("blockquote",[t("p",[s._v("作者平时也得工作和干活~，尽量在有空的时候不断的去更新该博客...")]),s._v(" "),t("p",[s._v("如果有相关问题或反馈，可以加作者微信（微信号：SPE3SRU3STAY）")])]),s._v(" "),t("br"),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("学习中的疑问：")]),s._v(" "),t("p",[s._v("Kubernetes是如何根据Pod的"),t("code",[s._v("Requests配置和Limits配置")]),s._v("，来实现针对Pod的资源服务质量控制（QoS）的呢，这个过程中都发生了什么？")])]),s._v(" "),t("h2",{attrs:{id:"什么是requests和limits"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是requests和limits"}},[s._v("#")]),s._v(" 什么是Requests和Limits")]),s._v(" "),t("p",[s._v("在Kubernetes的QoS体系中，需要保证高可靠的Pod可以申请"),t("code",[s._v("可靠资源")]),s._v("，而一些非高可靠性的Pod可以申请"),t("code",[s._v("可靠性较低")]),s._v("或"),t("code",[s._v("不可靠")]),s._v("的资源。")]),s._v(" "),t("p",[s._v("Pod容器资源的配置分为Requests和Limits。")]),s._v(" "),t("ul",[t("li",[s._v("Requests：是Kubernetes调度时能为容器提供可保证的资源量（最低保障）。")]),s._v(" "),t("li",[s._v("Limits：是系统允许容器运行时可能使用的资源量的上限（最高上限）。")])]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("小提示：")]),s._v(" "),t("p",[s._v("Pod级别的资源配置是通过计算Pod内"),t("code",[s._v("所有容器资源配置")]),s._v("的总和得出来的。")])]),s._v(" "),t("h2",{attrs:{id:"超售机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#超售机制"}},[s._v("#")]),s._v(" 超售机制")]),s._v(" "),t("p",[s._v("Kubernetes中Pod的Requests和Limits资源配置有如下特点：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("如果Pod配置的Requests值"),t("code",[s._v("等于")]),s._v("Limits值，那么该Pod可以获得的资源是"),t("code",[s._v("完全可靠")]),s._v("的。")])]),s._v(" "),t("li",[t("p",[s._v("如果Pod的Requests值"),t("code",[s._v("小于")]),s._v("Limits值，那么该Pod获得资源可以分为两个部分关注：")]),s._v(" "),t("ul",[t("li",[t("p",[t("code",[s._v("完全可靠的资源")]),s._v("，资源量的大小等于Requests值；")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("不可靠的资源")]),s._v("，资源量最大等于Limits与Requests的差额，这份不可靠的资源能够申请多少，取决于当时主机上容器可用资源的余量。")])])])])]),s._v(" "),t("p",[s._v("通过这种机制，Kubernetes可以实现节点资源的超售（Over Subscription），例如：")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("点击查看示例")]),s._v(" "),t("ul",[t("li",[s._v("在CPU完全充足的情况下，某机器共有32GiB内存可供容器使用。")]),s._v(" "),t("li",[s._v("将一个容器的Requests值为1GiB、Limits值为2GiB。")]),s._v(" "),t("li",[s._v("那么在该机器上最多可以同时运行32个容器，每个容器最多可以使用2GiB内存。")]),s._v(" "),t("li",[s._v("如果这些容器的"),t("code",[s._v("内存使用峰值")]),s._v("能错开，那么所有容器都可以正常运行。")])])]),s._v(" "),t("p",[s._v("超售机制能有效提高资源的利用率，也不会影响容器申请的"),t("code",[s._v("完全可靠资源")]),s._v("的可靠性.")]),s._v(" "),t("h2",{attrs:{id:"限制机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#限制机制"}},[s._v("#")]),s._v(" 限制机制")]),s._v(" "),t("p",[s._v("Requests和Limits对不同计算资源类型的限制机制")]),s._v(" "),t("p",[s._v("根据上文的内容可知，容器的资源配置满足以下两个条件：")]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("核心条件：")]),s._v(" "),t("ul",[t("li",[s._v("Requests <= 节点可用资源")]),s._v(" "),t("li",[s._v("Requests <= Limits")])])]),s._v(" "),t("p",[s._v("Kubernetes根据Pod配置的Requests值来调度Pod，Pod在成功调度之后会得到Requests值定义的资源来运行；如果Pod所在机器上的资源有空余，则Pod可以申请更多的资源，最多不能超过Limits的值。")]),s._v(" "),t("p",[s._v("下面看一下Requests和Limits针对不同计算资源类型的"),t("code",[s._v("限制机制")]),s._v("的有什么差异，这种差异主要取决于计算资源类型是"),t("code",[s._v("可压缩资源")]),s._v("还是"),t("code",[s._v("不可压缩资源")]),s._v("。")]),s._v(" "),t("h3",{attrs:{id:"可压缩资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可压缩资源"}},[s._v("#")]),s._v(" 可压缩资源")]),s._v(" "),t("p",[s._v("Kubernetes目前支持的可压缩资源是CPU。")]),s._v(" "),t("p",[s._v("Pod可以得到Requests配置的CPU使用量，而使用超过Requests值的部分取决于"),t("code",[s._v("系统的负载和调度")]),s._v("。")]),s._v(" "),t("blockquote",[t("p",[s._v("不过由于目前Kubernetes和Docker的CPU隔离机制都是在容器级别起作用的，所以Pod级别的资源配置并不能完全得到保障；Pod级别的cgroup正在紧锣密鼓的开发中，如果将来引入，就可以确保Pod级别的资源配置准确运行。")])]),s._v(" "),t("p",[s._v("空闲的CPU资源按照容器Requests值的比例分配。举例说明：")]),s._v(" "),t("ul",[t("li",[s._v("容器A的CPU配置为"),t("code",[s._v("Requests 1")]),s._v("、"),t("code",[s._v("Limits 10")])]),s._v(" "),t("li",[s._v("容器B的CPU配置为"),t("code",[s._v("Requests 2")]),s._v("、"),t("code",[s._v("Limits 8")])])]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("点击查看示例")]),s._v(" "),t("blockquote",[t("p",[s._v("A和B同时运行在一个节点上，初始状态下容器的可用CPU为"),t("code",[s._v("3 cores")]),s._v("，那么A和B恰好得到在其Requests中定义的CPU用量，即1CPU和2CPU。"),t("br"),s._v("\n~"),t("br"),s._v("\n如果A和B都需要更多的CPU资源，而恰好此时系统的其它任务释放了1.5CPU，那么这1.5CPU将按照A和B的Requests值的比例"),t("code",[s._v("1:2")]),s._v("分配给A和B，即最终A可以使用1.5CPU，B可以使用3CPU。"),t("br"),s._v("\n~"),t("br"),s._v("\n如果A的CPU用量超过了"),t("code",[s._v("Limits 10")]),s._v("的配置用量，那么cgroups会对Pod中容器的CPU用量进行限流（Throttled）。"),t("br"),s._v("\n~"),t("br"),s._v("\n如果A的CPU用量没有配置"),t("code",[s._v("Limits 10")]),s._v("的限制，那么A回去尝试抢占所有空闲的CPU资源（Kubernetes从1.2版本开始，默认开启--cpu-cfs-quota参数，因此在默认情况下必须配置Limits）。")])])]),s._v(" "),t("h3",{attrs:{id:"不可压缩资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不可压缩资源"}},[s._v("#")]),s._v(" 不可压缩资源")]),s._v(" "),t("p",[s._v("Kubernetes目前支持的不可压缩资源是内存。")]),s._v(" "),t("p",[s._v("Pod可以得到在Requests中配置的内存。")]),s._v(" "),t("p",[s._v("如果Pod的内存用量小于它的Requests的配置，那么这个Pod可以正常运行（除非出现炒作系统级别内存不足等严重问题）；如果Pod的内存容量超过了它的Requests配置，那么这个Pod有可能被Kubernetes “杀掉”。")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("点击查看示例")]),s._v(" "),t("blockquote",[t("p",[s._v("比如PodA使用了超过Requests而不到Limits的内存量，此时同一机器上另一个PodB之前只使用了远少于自己的Requests值的内存，此时程序压力增大，PodB向系统申请的总量不超过自己的Requests值的内存，那么Kubernetes可能会直接 “杀掉” PodA。"),t("br"),s._v("\n~"),t("br"),s._v("\n另外一种情况是PodA使用了超过Requests而不到Limits的内存，此时Kubernetes将一个新的Pod调度到这台机器上，新的Pod需要使用内存，而只有PodA使用了超过了自己Requests值的内存，那么Kubernetes也可能会 “杀掉” PodA来释放内存资源。")])])]),s._v(" "),t("p",[s._v("如果有Pod的内存用量超过了它Limits设置，那么操作系统内核会 “杀掉” Pod所有容器的所有进程中"),t("code",[s._v("内存使用量最多")]),s._v("的一个，直到内存不超过Limits时为止。")]),s._v(" "),t("h2",{attrs:{id:"对调度策略的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对调度策略的影响"}},[s._v("#")]),s._v(" 对调度策略的影响")]),s._v(" "),t("ul",[t("li",[s._v("Kubernetes的kube-scheduler通过计算Pod中所有容器的Requests的总和来决定对Pod的调度。")]),s._v(" "),t("li",[s._v("不管是CPU还是内存，Kubernetes调度器和Kubelet节点代理都会确保节点上所有Pod的Requests总和不会超过在该节点上可分配给容器使用的资源容量上线。")])]),s._v(" "),t("h2",{attrs:{id:"服务质量等级-qos-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务质量等级-qos-classes"}},[s._v("#")]),s._v(" 服务质量等级（QoS Classes）")]),s._v(" "),t("p",[s._v("在一个超用（Over Committed，容器Limits总和大于系统容量上线）的系统中，容器负载的波动可能导致操作系统的资源不足，最终导致部分容器被 “杀掉”。")]),s._v(" "),t("p",[s._v("在这种情况下，我们当然会希望优先 “杀掉” 那些不太重要的容器，那么如何平衡重要程度呢？")]),s._v(" "),t("p",[s._v("Kubernetes量容器划分成3个QoS等级：")]),s._v(" "),t("ul",[t("li",[s._v("Guaranteed（完全可靠）")]),s._v(" "),t("li",[s._v("Burstable（弹性波动、较可靠的）")]),s._v(" "),t("li",[s._v("BestEffort（尽力而为、不太可靠的）")])]),s._v(" "),t("p",[s._v("从理论上来说，QoS级别应该做为一个单独的参数来提供API，并由用户对Pod进行配置，这种配置应该与Requests和Limits无关。")]),s._v(" "),t("p",[s._v("但在当前版本的Kubernetes设计中，为了简化模式及避免引入太多的复杂性，QoS级别直接由Requests和Limits定义。")]),s._v(" "),t("p",[s._v("在Kubernetes中，容器的QoS级别等于容器所在Pod的QoS级别，而Kubernetes的资源配置定了Pod的三种QoS级别：")]),s._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[s._v("三大分类：")]),s._v(" "),t("ul",[t("li",[s._v("Guaranteed")])]),s._v(" "),t("blockquote",[t("p",[s._v("如果Pod中的所有容器对所有资源类型都定义了Requests和Limits，并且所有容器的Requests和Limits的值都相等（且都不为0），那么该Pod的QoS级别就是Guaranteed。")])]),s._v(" "),t("ul",[t("li",[s._v("BestEffort")])]),s._v(" "),t("blockquote",[t("p",[s._v("如果Pod中所有容器都未定义资源配置（Requests和Limits都未定义），那么该Pod的QoS级别就是BestEffort。")])]),s._v(" "),t("ul",[t("li",[s._v("Burstable")])]),s._v(" "),t("blockquote",[t("p",[s._v("当一个Pod即不为"),t("code",[s._v("Guaranteed级别")]),s._v("，也不为"),t("code",[s._v("BestEffort级别")]),s._v("时，该Pod的QoS级别就是Burstable。Burstable级别的Pod涉及两种情况：")]),s._v(" "),t("ul",[t("li",[s._v("第一种情况：Pod中的一部分容器在一种或多种资源类型的资源配置中定义了Requests值和Limits值（都不为0），且Requests值小于Limits值。"),t("br"),s._v("\n~")]),s._v(" "),t("li",[s._v("第二种情况：Pod中的一部分容器未定义资源配置（Requests和Limits都未定义）。注意：在容器未定义Limits时，Limits值默认等于节点资源容量的上限。")])])])]),s._v(" "),t("h3",{attrs:{id:"kubernetes-qos的工作特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-qos的工作特点"}},[s._v("#")]),s._v(" Kubernetes QoS的工作特点")]),s._v(" "),t("p",[s._v("在Pod的CPU Requests无法得到满足（比如节点的系统级任务占用过多CPU，导致无法分配足够的CPU给容器使用）时，容器得到的CPU会被压缩限流。")]),s._v(" "),t("p",[s._v("由于内存是不可压缩的资源，所以针对内存资源紧缺的情况，会按照以下逻辑处理。")]),s._v(" "),t("p",[s._v("（1） BestEffort Pod的优先级最低，在这类Pod中运行的进程会在系统内存紧缺时被第一优先级 “杀掉”。当然，从另一个角度来看，BestEffort Pod由于没有设置资源Limits，所以在资源充足时，他们可以充分使用所有闲置资源。")]),s._v(" "),t("p",[s._v("（2） Burstable Pod的优先级居中，这类Pod在初始时会被分配较少的可靠资源，但可以按需申请更多的资源。当然，如果整个系统内存紧缺，🈶没有BestEffort容器可以被杀掉以释放资源，那么这类Pod中的进程可能被 “杀掉” 。")]),s._v(" "),t("p",[s._v("（3）Guaranteed Pod的优先级最高，而且一般情况下这类Pod只要不超过其资源Limits的限制就不会被 “杀掉”。当然，如果整个系统内存紧缺，又没有其它更低优先级的容器可以被 “杀掉” 以释放资源，那么这类Pod中的进程也可能会被 “杀掉”。")]),s._v(" "),t("h3",{attrs:{id:"oom计分规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#oom计分规则"}},[s._v("#")]),s._v(" OOM计分规则")]),s._v(" "),t("p",[s._v("OOM（Out Of Memory）积分规则包括如下内容：")]),s._v(" "),t("ul",[t("li",[s._v("OOM积分的计算方法：")])]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("计算方法")]),s._v(" "),t("ul",[t("li",[s._v("计算进程所使用的的内存在系统中所占的百分比，取其中不含百分号的数值，再乘以10，该结果是进程OOM的基础分。")]),s._v(" "),t("li"),s._v(" "),t("li",[s._v("讲进程OOM基础分的分值再加上这个进程的oom_SCORE_ADJ（分数调整）值，做为进程OOM的最终分值（除root启动的进程外）。")]),s._v(" "),t("li"),s._v(" "),t("li",[s._v("在系统发生OOM时，OOM Killer会优先“杀掉”OOM计分更高的进程.")])])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("进程的OOM计分的基本分数值范围是0~1000，如果A进程的调整至OOM_SCORE_ADJ减去B进程的调整值的结果大于1000，那么A进程的OOM计分最终值必然大于B进程，会有限“杀掉”A进程。")])]),s._v(" "),t("li",[t("p",[s._v("不论调整OOM_SCORE_ADJ值为多少，任何进程的最终分值范围也是0~1000。")])])]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("QoS等级")]),s._v(" "),t("th",[s._v("oom_score_adj")])])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("Guaranteed")]),s._v(" "),t("td",[s._v("-998")])]),s._v(" "),t("tr",[t("td",[s._v("Burstable")]),s._v(" "),t("td",[s._v("min(max(1,1000-(1000*memoryRequestBytes)/machineMemoryCapacityBytes),999)")])]),s._v(" "),t("tr",[t("td",[s._v("BestEffort")]),s._v(" "),t("td",[s._v("1000")])])])]),s._v(" "),t("p",[s._v("对表中的内容说明如下：")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("点击查看说明详情")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("BestEffort Pod设置OOM_SCORE_ADJ调整值为1000，因此BestEffort Pod中容器里所有进程的OOM最终分肯定是1000.")])]),s._v(" "),t("li",[t("p",[s._v("Guaranteed Pod设置OOM_SCORT_ADJ调整值为-998，因此Guaranteed POd中容器里所有进程的OOM最终分一般是0或1（因为基础分不可能是1000）。")])]),s._v(" "),t("li",[t("p",[s._v("对Burstable Pod规则分情况说明：")]),s._v(" "),t("ul",[t("li",[s._v("如果Burstable Pod的内存Requests超过系统可用内存的99.8%，那么这个Pod的OOM_SCORE_ADJ调整值固定为2；")]),s._v(" "),t("li",[s._v("否则，设置OOM_SCORE_ADJ调整值为"),t("code",[s._v("1000-10*(% of memory requested)")]),s._v("；")]),s._v(" "),t("li",[s._v("如果内容Requests为0，那么OOM__SCORE_ADJ调整值固定为999.")]),s._v(" "),t("li",[s._v("这样的规则能确保OOM_SCORE_ADJ调整值的范围为2~999，而Burstable Pod中所有进程的OOM最终分数范围为2~1000.")]),s._v(" "),t("li",[s._v("Burstable Pod进程的OOM最终分数始终大于Cuaranteed Pod的进程得分，因此他们会被优先“杀掉”。")]),s._v(" "),t("li",[s._v("如果一个Burstable Pod使用的内存比他的内存Requests少，那么可以肯定的事，他的所有进程的OOM最终分数会小于1000，此时能确保它的优先级高于BestEffort Pod。")]),s._v(" "),t("li",[s._v("如果在一个Burstable Pod的某个容器中某个进程使用的内存比容器的Requests值高，那么这个进程的OOM最终分数就会是1000，否则他的OOM最终分数会小于1000。")]),s._v(" "),t("li",[s._v("假设在下面的容器中有一个占用内存非常大的进程，那么当一个使用内存超过其Requests的Burstable Pod与另外一个使用内存少于其Requests的Burstable Pod发生内存竞争冲突时，前者的进程会被系统“杀掉”。")]),s._v(" "),t("li",[s._v("如果在一个Burstable Pod内部有多个进程的多个容器发生内存竞争冲突，那么此时OOM评分只能做为参考，不能保证完全按照资源配置的定义来执行OOM Kill。")])])]),s._v(" "),t("li",[t("p",[s._v("OOM还有一些特殊的计分规则：")]),s._v(" "),t("ul",[t("li",[s._v("kubelet进程和Docker进程的调整值OOM_SOCRE_ADJ始终为-998。")]),s._v(" "),t("li",[s._v("如果配置进程调整值OOM_SCORE_ADJ为-999，那么这类进程不会被OOM Killer“杀掉”。")])])])])]),s._v(" "),t("h3",{attrs:{id:"qos的演进"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#qos的演进"}},[s._v("#")]),s._v(" QoS的演进")]),s._v(" "),t("p",[s._v("目前Kubernetes基于QoS的潮涌机制日趋完善，但还有一些限制。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("不足之处")]),s._v(" "),t("ul",[t("li",[s._v("不支持内存Swap，当前的QoS策略都假定了主机不启动内存swap，Kubernetes从1.8版本开始默认关闭Swap特性，如果主机启动了Swap功能，上面的QoS策略就可能失效。")]),s._v(" "),t("li"),s._v(" "),t("li",[s._v("缺乏更丰富的QoS策略，当前的QoS策略都是基于Pod的（Requests和Limits）来定义的。社区有考虑过引入自定义QoS的功能，但是这一块目前还不太明朗，等待后续持续关注了解清楚后再进行内容的追加。")])])]),s._v(" "),t("blockquote",[t("p",[s._v("（到此为止，Resource QoS 原理分析完毕）")])]),s._v(" "),t("p",[t("br"),t("br"),t("br")]),t("hr"),t("br"),t("br"),t("br"),t("p"),s._v(" "),t("h4",{attrs:{id:"帮助作者改进文档"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#帮助作者改进文档"}},[s._v("#")]),s._v(" 帮助作者改进文档")]),s._v(" "),t("p",[s._v("如果您喜欢这篇文档，想让它变得更好，您可以：")]),s._v(" "),t("ul",[t("li",[s._v("推荐这篇文档，让更多的人知道。")]),s._v(" "),t("li",[s._v("给作者反馈和建议："),t("em",[t("em",[t("a",{attrs:{href:"mailto:tianye3223@gmail.com"}},[s._v("tianye3223@gmail.com")])])])])]),s._v(" "),t("p",[t("br"),t("br"),t("br"),t("br"),t("br")])])}),[],!1,null,null,null);e.default=v.exports}}]);