(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{426:function(v,e,_){"use strict";_.r(e);var o=_(24),t=Object(o.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"深入理解资源平衡与二次调度机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深入理解资源平衡与二次调度机制"}},[v._v("#")]),v._v(" 深入理解资源平衡与二次调度机制")]),v._v(" "),_("blockquote",[_("p",[v._v("作者平时也得工作和干活~，尽量在有空的时候不断的去更新该博客...")]),v._v(" "),_("p",[v._v("如果有相关问题或反馈，可以加作者微信（微信号：SPE3SRU3STAY）")])]),v._v(" "),_("br"),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("本文默认：")]),v._v(" "),_("p",[_("code",[v._v("您已经了解以下组件的“基本概念”和“常规用法”：")])]),v._v(" "),_("ul",[_("li",[v._v("kube-apiserver")]),v._v(" "),_("li",[v._v("kube-controller-manager")]),v._v(" "),_("li",[v._v("kube-scheduler")]),v._v(" "),_("li",[v._v("kube-proxy")]),v._v(" "),_("li",[v._v("kubectl")]),v._v(" "),_("li",[v._v("kubelet")]),v._v(" "),_("li",[v._v("etcd")])])]),v._v(" "),_("h2",{attrs:{id:"要解决的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#要解决的问题"}},[v._v("#")]),v._v(" 要解决的问题")]),v._v(" "),_("h4",{attrs:{id:"与朋友闲聊时提起的内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与朋友闲聊时提起的内容"}},[v._v("#")]),v._v(" 与朋友闲聊时提起的内容：")]),v._v(" "),_("blockquote",[_("p",[v._v("        互联网业务都会一个明显的波峰波谷，To C业务的波峰波谷会更加剧烈，波峰波谷可能会有两个数量级的一个差异。")]),v._v(" "),_("p",[v._v("        当研发在波谷的时候进行一次发布，这时候就会触发容器的一次重新调度，比如像我这个服务有几十个 Pod 的，可能会有十多个 pod 调度到一台机器，因为这时候的机器的使用率很低，就是服务怎么调度其实都可以。")]),v._v(" "),_("p",[v._v("        但是到了晚高峰的时候，我的每一个 pod 资源的使用率就上来的，CPU 使用高了，它的吞吐也高了，然后我这十个Pod都在同一个机器上，我这台机器就会出现一些资源的瓶颈。")])]),v._v(" "),_("h4",{attrs:{id:"从中抽象出的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从中抽象出的问题"}},[v._v("#")]),v._v(" 从中抽象出的问题：")]),v._v(" "),_("blockquote",[_("p",[v._v("Node节点资源调度不均匀，"),_("code",[v._v("波峰")]),v._v("与"),_("code",[v._v("波谷")]),v._v("之间的访问量诧异巨大，导致各节点资源利用不均衡，高负载Pod扎堆聚集在几个特定的Node之上，从而"),_("code",[v._v("触发资源瓶颈")]),v._v("和"),_("code",[v._v("某些运维成本的增加")]),v._v("。")])]),v._v(" "),_("p",[v._v("以上的这个问题该如何去解决？")]),v._v(" "),_("h2",{attrs:{id:"原理探索"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原理探索"}},[v._v("#")]),v._v(" 原理探索")]),v._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[v._v("解决思路：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("kube-schduler调度器只能完成对Pod的"),_("code",[v._v("一次调度")]),v._v("。当Pod被调度到指定节点上之后，kube-scheduler就无法再次调度这个运行中的Pod。")])]),v._v(" "),_("li",[_("p",[v._v("而我们想要的是"),_("code",[v._v("全时段")]),v._v("的对Pod的某种动态调度，以求来达到Node资源平衡利用的最终预期。（比如每10分钟重新调度一次，一天差不多调度144次）")])]),v._v(" "),_("li",[_("p",[v._v("那是不是我们可以手动的去"),_("code",[v._v("杀死")]),v._v("某些Pod，来让这些Pod回归到kube-scheduler监听的"),_("code",[v._v("未调度Pod清单")]),v._v("中，触发kube-scheduler的二次调度。")])]),v._v(" "),_("li",[_("p",[v._v("同时手动"),_("code",[v._v("杀死")]),v._v("的Pod时，我们是不是应该还得引入某种条件和策略；不能随意乱杀，要是能按照"),_("code",[v._v("某种策略或者条件")]),v._v("的去杀死指定的Pod，那么解决方案会不会更优美。")])]),v._v(" "),_("li",[_("p",[v._v("接着利用"),_("code",[v._v("（Deployment或StatefulSets总是会维持一个期望数量Pod的特性）")]),v._v("拉起新的Pod，自然而然的让新Pod重走一遍kube-scheduler的"),_("code",[v._v("过滤链")]),v._v("和"),_("code",[v._v("打分链")]),v._v("，以便为新Pod重新寻找到一个"),_("code",[v._v("资源富裕的Node节点")]),v._v("，最终把Pod调度分配过去。")])]),v._v(" "),_("li",[_("p",[v._v("最后一步，我们是不是可以把上面每一次"),_("code",[v._v("杀死")]),v._v("Pod的过程，设定为某种自动化，让它每10分钟去执行一次，完全解放我们的双手。")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("调度器通过Kubernetes通过list-watch机制来发现集群中尚未被调度Node上的Pod，感兴趣的同学可以自行查阅相关概念。")])]),v._v(" "),_("p",[v._v("基于以上的解决方案，我们可以得出来一些清晰的理论支撑：")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("理论支撑：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("仅仅依赖kube-scheduler调度器无法"),_("code",[v._v("全时段")]),v._v("的动态调整Node资源利用率。")])]),v._v(" "),_("li",[_("p",[v._v("我们必须引入"),_("code",[v._v("某种二次调度的概念")]),v._v("来实现对Pod资源的再调度，以求达成"),_("code",[v._v("全时段")]),v._v("内资源的动态调度与平衡。")])]),v._v(" "),_("li",[_("p",[v._v("如果kube-scheduler自带调度策略不够用，我们可以开发"),_("code",[v._v("自定义调度器")]),v._v("来实现更加精细化的调度需求。")])])])]),v._v(" "),_("p",[v._v("自定义调度器分为四大类：")]),v._v(" "),_("blockquote",[_("p",[v._v("分类一："),_("br"),v._v("\n直接clone官方的kube-scheduler来修改源码（不推荐）"),_("br"),v._v(" "),_("br"),_("br"),v._v("\n分类二："),_("br"),v._v("\n单独开发一个调度程序，使其和kube-scheduler同时运行，可以指定Pod的spec.schedulerName属性，来让当前Pod选择遵从哪个调度器的调度指令。"),_("br"),v._v(" "),_("br"),_("br"),v._v("\n分类三："),_("br"),v._v("\n使用Scheduler extender（调度程序扩展器），利用webhook去和上游调度程序兼容。"),_("code",[v._v("（kubernetes-1.16版本之后已经废弃）")]),_("br"),v._v(" "),_("br"),_("br"),v._v("\n分类四："),_("br"),v._v("\n通过调度框架（Scheduler Framework）在整个调度链路中追加扩展点，我个地方我自己的理解是：有点类似于Vue.js页面加载过程中的那种生命周期一样，我们可以利用Scheduler Framework框架，来对生命周期中指定的环节进行再加工。"),_("code",[v._v('（kubernetes-1.15之后引入，同时也废弃了上文中的"调度程序扩展器"的用法）')])])]),v._v(" "),_("h2",{attrs:{id:"最终方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最终方案"}},[v._v("#")]),v._v(" 最终方案")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("波峰波谷之间的变化是随着"),_("code",[v._v("时间线")]),v._v("来变化的，因此不论是【kube-scheduler的调度策略】还是【自己开发的调度器】，本质上都无法做到动态调整，所以引入【二次调度】的机制就尤为重要。")])]),v._v(" "),_("li",[_("p",[v._v("通过定时性的运行【二次调度】程序，去“杀死”那些Node节点上超过阈值的资源占用，然后利用kube-scheduler的重新调度，彻底实现Node资源的再平衡。")])]),v._v(" "),_("li",[_("p",[v._v("在技术选型时，我们这里选择"),_("code",[v._v("DeScheduler工具")]),v._v("来实现以上问题的解决。")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img.taycc.com/picgo/%E4%BA%8C%E6%AC%A1%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B-3.png",alt:"二次调度过程-3"}})]),v._v(" "),_("h2",{attrs:{id:"deschduler使用教程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#deschduler使用教程"}},[v._v("#")]),v._v(" DeSchduler使用教程")]),v._v(" "),_("p",[v._v("略..."),_("br"),v._v(" "),_("code",[v._v("（网上一搜一大堆）")])]),v._v(" "),_("h2",{attrs:{id:"自定义调度器-·-从哪里开始"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义调度器-·-从哪里开始"}},[v._v("#")]),v._v(" 自定义调度器 · 从哪里开始？")]),v._v(" "),_("p",[v._v("        有很多公司会去考虑开发"),_("code",[v._v("自定义调度器")]),v._v("来解决某些"),_("code",[v._v("精细化调度")]),v._v("的问题，那么我们应该从哪里开始入手进行开发呢？从上文中可以看出，整个"),_("code",[v._v("调度、二次调度")]),v._v("的闭环中，有"),_("code",[v._v("两个环节")]),v._v("都可以适当的插入一些自己开发的东西：")]),v._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[v._v("自定义开发的思考：")]),v._v(" "),_("p",[v._v("环节一："),_("br"),v._v("\n从"),_("code",[v._v("Scheduler Framework（调度框架）")]),v._v("这个位置进行的开发：")]),v._v(" "),_("ul",[_("li",[v._v("可以扩展kube-scheduler的能力（固然这一部分运维成本会增加一些，但是长期来看是非常利好的，可以从粗放型调度向精细化型调度转变）。")])]),v._v(" "),_("br"),v._v(" "),_("p",[v._v("环节二："),_("br"),v._v("\n从"),_("code",[v._v("Descheduler（二次调度）")]),v._v("这个位置进行的开发：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("从这个位置做开发，有一个误区："),_("code",[v._v("就是建议不要去跟kube-scheduler抢夺调度能力")])])]),v._v(" "),_("li",[_("p",[v._v("我们可以自己开发一个【二次调度工具】，去判断当前哪些Node的利用率过高，或者集成上"),_("code",[v._v("Pod的亲和性调度")]),v._v("再或者兼容"),_("code",[v._v("污点容忍度")]),v._v("等等某些特性，去当做"),_("code",[v._v("“杀死”")]),v._v("Pod的某种阈值和依据；甚至不相信kube-apiserver中查询到的Node资源利用率，而是"),_("code",[v._v("自己对接Prometheus数据源实时抓取Node真实监控利用率")]),v._v("来当做判断依据都是可以的。")])]),v._v(" "),_("li",[_("p",[v._v("把自己的开发产物定位在"),_("code",[v._v("仅仅只是判断Node的资源利用状态，可以对接QoS机制杀死指定Pod的工具")]),v._v("这个角色位置上。实际的调度还是由kube-scheduler去做，这样的综合运维成本会被压低很多。")])]),v._v(" "),_("li",[_("p",[v._v("因为如果我们人为开发"),_("code",[v._v("自定义调度器")]),v._v("去抢夺kube-scheduler的调度能力的话，就必然要实现一条【过滤链】和【打分链】，这种开发、后期维护、版本兼容性、等等问题的持续性伤害，可能会让"),_("code",[v._v("运维综合成本")]),v._v("变得很痛苦。")])])])]),v._v(" "),_("p",[v._v("上面这个问题涉及到"),_("code",[v._v("综合运维成本")]),v._v("，可能作者的想法也不太正确，视角有所缺失等等，算作是抛砖引玉，期待着和大家一起交流和探讨，更欢迎大佬多多批评和指正~。")]),v._v(" "),_("blockquote",[_("p",[v._v("（全文到此结束）")])]),v._v(" "),_("p",[_("br"),_("br"),_("br")]),_("hr"),_("br"),_("br"),_("br"),_("p"),v._v(" "),_("h4",{attrs:{id:"帮助作者改进文档"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#帮助作者改进文档"}},[v._v("#")]),v._v(" 帮助作者改进文档")]),v._v(" "),_("p",[v._v("如果您喜欢这篇文档，想让它变得更好，您可以：")]),v._v(" "),_("ul",[_("li",[v._v("推荐这篇文档，让更多的人知道。")]),v._v(" "),_("li",[v._v("给作者反馈和建议："),_("em",[_("em",[_("a",{attrs:{href:"mailto:tianye3223@gmail.com"}},[v._v("tianye3223@gmail.com")])])])])]),v._v(" "),_("p",[_("br"),_("br"),_("br"),_("br"),_("br")])])}),[],!1,null,null,null);e.default=t.exports}}]);